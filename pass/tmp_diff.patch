diff --git a/pass/Symbolizer.cpp b/pass/Symbolizer.cpp
index 364196f..b35b166 100644
--- a/pass/Symbolizer.cpp
+++ b/pass/Symbolizer.cpp
@@ -383,10 +383,11 @@ void Symbolizer::visitSelectInst(SelectInst &I) {
     Value * falseSymExpr = getSymbolicExpression(I.getFalseValue());
     if ( trueSymExpr != ConstantInt::getFalse(I.getContext()) ||
             falseSymExpr != ConstantInt::getFalse(I.getContext()) ) {
-        auto *data = IRB.CreateSelect(
+        SelectInst *data = cast<SelectInst>(IRB.CreateSelect(
                 I.getCondition(), trueSymExpr,
-                falseSymExpr);
+                falseSymExpr));
         symbolicExpressions[&I] = data;
+        assignSymID(data, getNextID());
     }
 }
 
@@ -1405,6 +1406,10 @@ void Symbolizer::createDFGAndReplace(llvm::Function& F, std::string filename){
                     g.AddPhiVertice(NodeFalseLeafPhi, userSymID, blockID);
                 }
             }
+            else if(SelectInst* selectInst = dyn_cast<SelectInst>(&eachInst); selectInst != nullptr && symbolicIDs.find(selectInst) != symbolicIDs.end()){
+                unsigned userSymID = getSymIDFromSym(selectInst);
+
+            }
             if(!isa<CallInst>(&eachInst)){
                 continue;
             }
@@ -1575,7 +1580,7 @@ void Symbolizer::createDFGAndReplace(llvm::Function& F, std::string filename){
 
                 PHINode* reportingPhi = nullptr;
                 unsigned numIncomingValue = symPhi->getNumIncomingValues();
-                unsigned userSymID = getSymIDFromSymPhi(symPhi);
+                unsigned userSymID = getSymIDFromSym(symPhi);
                 auto phi_status = phiSymbolicIDs.find(symPhi)->second;
                 if(isa<TruePhi>(phi_status)){
                     IRBuilder<> IRB(&*symPhi->getParent()->getFirstInsertionPt());
@@ -1610,6 +1615,7 @@ void Symbolizer::createDFGAndReplace(llvm::Function& F, std::string filename){
                     unsigned incomingValueSymID = getSymIDFromSym(incomingValue);
                     //assert(incomingValueSymID != 0); // incoming symid could be zero
                     // add incoming BBID as edge property just to double check
+
                     g.AddPhiEdge(incomingValueSymID, userSymID,incoming, incomingBBID, 0);
                 }
             }
diff --git a/pass/Symbolizer.h b/pass/Symbolizer.h
index f519409..211d20e 100644
--- a/pass/Symbolizer.h
+++ b/pass/Symbolizer.h
@@ -277,18 +277,22 @@ public:
 
     unsigned getSymIDFromSym(llvm::Value *V) {
         unsigned retSymID = 0;
-        if(auto nonPhiSymExpr = llvm::dyn_cast<llvm::CallInst>(V)){
+        if(llvm::isa<llvm::CallInst>(V) ){
+            llvm::CallInst* nonPhiSymExpr = llvm::cast<llvm::CallInst>(V);
             retSymID = getSymIDFromSymExpr(nonPhiSymExpr);
-        }else if(auto phiSymExpr = llvm::dyn_cast<llvm::PHINode>(V)){
+        }
+        else if(auto phiSymExpr = llvm::dyn_cast<llvm::PHINode>(V)){
             retSymID = getSymIDFromSymPhi(phiSymExpr);
         }else if(auto symConst = llvm::dyn_cast<llvm::ConstantInt>(V); V->getType() == isSymType && symConst != nullptr && symConst->isZero() ){
             return 0;
         }else{
+            llvm::errs() << *V<<'\n';
             llvm_unreachable("sym expr can only be of phiNode or call inst or constant false");
         }
         return retSymID;
     }
-    unsigned int getSymIDFromSymExpr(llvm::CallInst *V) {
+    unsigned int getSymIDFromSymExpr(llvm::Instruction *V) {
+        assert(llvm::isa<llvm::SelectInst>(V) || llvm::isa<llvm::CallInst>(V));
         auto exprIt = symbolicIDs.find(V);
         assert(exprIt != symbolicIDs.end());
         return exprIt->second;
@@ -415,12 +419,12 @@ public:
         }
         return id;
     }
-    void assignSymID(llvm::CallInst * symcall, unsigned int ID){
-        auto exprIt = symbolicIDs.find(symcall);
+    void assignSymID(llvm::Instruction * symInst, unsigned int ID){
+        assert(llvm::isa<llvm::SelectInst>(symInst) || llvm::isa<llvm::CallInst>(symInst));
+        auto exprIt = symbolicIDs.find(symInst);
         assert(exprIt == symbolicIDs.end());
-        symbolicIDs[symcall] = ID;
+        symbolicIDs[symInst] = ID;
     }
-
     class TryAlternativeUnit{
     public:
         int symID;
@@ -690,8 +694,8 @@ public:
   /// finalizePHINodes invalidates it. We may want to pass the map around
   /// explicitly.
   llvm::ValueMap<llvm::Value *, llvm::Value *> symbolicExpressions;
-  /// Maps symbolic value to its IDs
-  llvm::ValueMap<llvm::CallInst *, unsigned int> symbolicIDs;
+  /// Maps symbolic value to its IDs (which can only be CallInst and )
+  llvm::ValueMap<llvm::Instruction *, unsigned int> symbolicIDs;
   // redirect the symID into a new one(as we are finer-grained by symcc(e.g, they didn't distinguish different branches for the SwitchInst, but we need to))
   std::map<unsigned int, unsigned int> symIdRedirect;
   /// Maps phi nodes to its IDs
diff --git a/pass/dfg/DataFlowGraph.cpp b/pass/dfg/DataFlowGraph.cpp
index ccaccb4..83f0e68 100644
--- a/pass/dfg/DataFlowGraph.cpp
+++ b/pass/dfg/DataFlowGraph.cpp
@@ -77,6 +77,7 @@ void SymDepGraph::AddEdge( vertex_t from, vertex_t to, unsigned arg_no){
 void SymDepGraph::AddPhiEdge(unsigned from_symid, unsigned to_symid, unsigned arg_no, unsigned incomingBB, unsigned dashed) {
     auto from = GetVerticeBySymID(from_symid);
     auto to = GetVerticeBySymID(to_symid);
+    //make sure both from and to nodes exists
     assert(from != GetVerticeEndIt());
     assert(to != GetVerticeEndIt());
     assert(graph[*to].nodeType == NodeTruePhi || graph[*to].nodeType == NodeFalseRootPhi || graph[*to].nodeType == NodeFalseLeafPhi );
